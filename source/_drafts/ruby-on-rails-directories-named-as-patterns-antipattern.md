---
title: Ruby on Rails directories named as patterns antipattern
layout: post
draft: true
tags:
  - ruby
  - rails
  -
---

When I was building my first Rails application in 2005 I remember a `components` directory was generated by `rails new`. At the time I had no clue what it was for but it's fascinating that 10 years after the fact I am 

I think 100% of the Rails applications I worked on follow this antipattern and I wanted to describe its problems and a better alternative.

I find putting classes in directories using their pattern name infective and counter-productive.

When you look at the following list:

{% highlight bash %}
ls -l app/
├── controllers
├── helpers
├── models
├── presenters
├── services
├── serializers
├── strategies
├── utils
└── views
{% endhighlight %}

I guess someone likes patterns but I gather nothing about the application intent or domain. 

I am not referring to Rails's conventional **MVC** directories: *models, views, controllers, helpers* they come with the framework and developers should know what they are for.

I am referring to the other directories: **presenters, services, serializers, strategies, utils**.

Inside you usually find hundreads of rarely namespaced files.

The result of this distubing practice is having completely unrelated code sharing the same place just because their race.

An example would be:

{% highlight bash %}
services/reservation_quote_recalculation_service.rb
strategies/quote_strategy.rb
specifications/obsolete_quote_specification.rb
{% endhighlight %}

When looking at the directory structure they appear to be completely unrelated.

But I update a reservation I have a `ReservationQuoteRecalculationService` using a `QuoteStrategy` using a `ObsoleteQuoteSpecification`. Those classes work together in the same boundary but the directory naming obfuscate that.

Another problem is that alongside `ReservationQuoteRecalculationService` I will have to navigate a multitude of unrelated classes.

## Use contexts

I like to build on the Rail conventions and put in `models` not just the *ActiveRecord* models but all the classes related to the **application domain model**.

Inside I add directories following a Ruby namespace highlighting the boundaries--sometime called bounded contexts--where those objects act.

An example could be an application for memory videogames with game designers creating them, players playing them. Two very different contexts: **workshop** and **gamezone**.

Another example is a private jet company that can book trips, update their trip as they are ongoing and billing. Again three very distinct contexts: **book**, **trip**, **bill**.

A content management that imports content from a legacy system allowing an editorial team to update some of the content and having users viewing that. Three contexts: **legacy_import**, **editorial**, **public**.

Of course those context will share code which is why I urge you to learn about component based Rails architecture, an effective way to set that dependency structure.

Continuing to group classes by their pattern instead of their context is a very bad decision that lead to unmaintainable code.

As the application grow those bounded context can be moved in to components to enforce a dependency structure. More about this on [LINK].
